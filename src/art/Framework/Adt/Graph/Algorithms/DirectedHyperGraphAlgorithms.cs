//..............................
// UI Lab Inc. Arthur Amshukov .
//..............................
using UILab.Art.Framework.Core.Diagnostics;

namespace UILab.Art.Framework.Adt.Graph;

/// <summary>
/// Some comments are generated by ChatGPT.
/// </summary>
public static class DirectedHyperGraphAlgorithms
{
    /// <summary>
    /// Gets the number of incoming edges incident to the vertex.
    /// If 𝑣 is in the target set of hyperedge 𝑒, we can say that 𝑒 is an incoming edge to 𝑣.
    /// </summary>
    public static count GetVertexInDegree(DirectedHyperGraph graph, DirectedVertex vertex)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(vertex, nameof(vertex));

        count degree = 0;

        foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
        {
            if(hyperEdge.Codomain.ContainsKey(vertex.Id))
            {
                degree++;
            }
        }

        return degree;
    }

    /// <summary>
    /// Gets the number of outcoming edges incident to the vertex.
    /// If 𝑣 is in the source set of hyperedge 𝑒, we can say that 𝑒 is an outgoing edge from 𝑣.
    /// </summary>
    public static count GetVertexOutDegree(DirectedHyperGraph graph, DirectedVertex vertex)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(vertex, nameof(vertex));

        count degree = 0;

        foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
        {
            if(hyperEdge.Domain.ContainsKey(vertex.Id))
            {
                degree++;
            }
        }

        return degree;
    }

    /// <summary>
    /// Gets the number of edges incident to the vertex.
    /// Vertex degree in a directed hypergraph can be split into in-degree and out-degree,
    /// depending on whether the vertex is part of the target or source set of the hyperedges.
    /// </summary>
    public static count GetVertexDegree(DirectedHyperGraph graph, DirectedVertex vertex)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(vertex, nameof(vertex));

        return GetVertexInDegree(graph, vertex) + GetVertexOutDegree(graph, vertex);
    }

    /// <summary>
    /// Checks if two vertices are adjacent.
    /// There is a hyperedge 𝑒 such that 𝑢 is in the source (domain) set of 𝑒 and 𝑣 is in the target (codomain) set of 𝑒.
    /// </summary>
    public static bool AreVerticesAdjacent(DirectedHyperGraph graph, DirectedVertex u, DirectedVertex v)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(v, nameof(v));
        Assert.NonNullReference(u, nameof(u));

        foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
        {
            if(hyperEdge.Domain.ContainsKey(v.Id) && hyperEdge.Codomain.ContainsKey(u.Id))
            {
                return true;
            }
        }

        return false;
    }

    public static IEnumerable<DirectedVertex> GetAdjacentVertices(DirectedHyperGraph graph, DirectedVertex u)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(u, nameof(u));

        foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
        {
            if(hyperEdge.Domain.ContainsKey(u.Id))
            {
                foreach(DirectedVertex v in hyperEdge.Codomain.Values)
                {
                    if(ReferenceEquals(u, v))
                        continue;

                    yield return v;
                }
            }
        }
    }

    /// <summary>
    /// A vertex is incident to a hyperedge if it belongs to the source or target set of that hyperedge.
    /// </summary>
    public static IEnumerable<DirectedHyperEdge> GetVertexIncidentHyperEdges(DirectedHyperGraph graph, DirectedVertex vertex)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(vertex, nameof(vertex));

        foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
        {
            if(hyperEdge.Domain.ContainsKey(vertex.Id) && hyperEdge.Codomain.ContainsKey(vertex.Id))
            {
                yield return hyperEdge;
            }
        }
    }

    public static bool IsVertexIsolated(DirectedHyperGraph graph, DirectedVertex vertex)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(vertex, nameof(vertex));

        return GetVertexDegree(graph, vertex) == 0;
    }

    public static bool IsVertexPendant(DirectedHyperGraph graph, DirectedVertex vertex)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(vertex, nameof(vertex));

        return GetVertexDegree(graph, vertex) == 1;
    }

    /// <summary>
    /// Out-Neighbors (or Forward Neighbors): Vertices that are in the target sets of hyperedges where the vertex is part of the source set.
    /// In other words, the out-neighbors of 𝑣 are the vertices that 𝑣 "points to" through the hyperedges in which 𝑣 is a source.
    /// </summary>
    public static IEnumerable<DirectedVertex> GetVertexInNeighbors(DirectedHyperGraph graph, DirectedVertex vertex)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(vertex, nameof(vertex));

        foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
        {
            if(hyperEdge.Codomain.ContainsKey(vertex.Id))
            {
                foreach(DirectedVertex neighbor in hyperEdge.Domain.Values)
                {
                    yield return neighbor;
                }
            }
        }
    }

    /// <summary>
    ///  In-Neighbors (or Backward Neighbors): Vertices that are in the source sets of hyperedges where the vertex is part of the target set.
    ///  The in-neighbors of 𝑣 are the vertices that "point to" 𝑣 through hyperedges in which 𝑣 is a target.
    /// </summary>
    public static IEnumerable<DirectedVertex> GetVertexOutNeighbors(DirectedHyperGraph graph, DirectedVertex vertex)
    {
        foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
        {
            if(hyperEdge.Domain.ContainsKey(vertex.Id))
            {
                foreach(DirectedVertex neighbor in hyperEdge.Codomain.Values)
                {
                    yield return neighbor;
                }
            }
        }
    }

    /// <summary>
    /// Total neighbors: The union of in-neighbors and out-neighbors, representing all vertices connected to the given vertex by directed hyperedges.
    /// </summary>
    public static IEnumerable<DirectedVertex> GetVertexNeighbors(DirectedHyperGraph graph, DirectedVertex vertex)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(vertex, nameof(vertex));

        return GetVertexOutNeighbors(graph, vertex).Union(GetVertexInNeighbors(graph, vertex));
    }

    /// <summary>
    /// Predecessors of a vertex 𝑣 in a directed hypergraph are the vertices in the source sets of hyperedges where 𝑣 is part of the target set.
    /// They represent the vertices that "point to" 𝑣.
    /// </summary>
    public static IEnumerable<DirectedVertex> CollectPredecessors(DirectedHyperGraph graph, DirectedVertex vertex)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(vertex, nameof(vertex));

        return GetVertexInNeighbors(graph, vertex);
    }

    /// <summary>
    /// Successors of a vertex 𝑣 in a directed hypergraph are the vertices in the target sets of hyperedges where 𝑣 is part of the source set.
    /// They represent the vertices that 𝑣 "points to."
    /// </summary>
    public static IEnumerable<DirectedVertex> CollectSuccessors(DirectedHyperGraph graph, DirectedVertex vertex)
    {
        Assert.NonNullReference(graph, nameof(graph));
        Assert.NonNullReference(vertex, nameof(vertex));

        return GetVertexOutNeighbors(graph, vertex);
    }

    /// <summary>
    /// Edge degree in a directed hypergraph is the total number of vertices in both the source and target sets of the hyperedge.
    /// </summary>
    public static count GetHyperEdgeDegree(DirectedHyperEdge hyperEdge)
    {
        Assert.NonNullReference(hyperEdge, nameof(hyperEdge));
        return hyperEdge.Domain.Count + hyperEdge.Codomain.Count;
    }

    /// <summary>
    /// In-adjacent edges: Two directed hyperedges share at least one vertex in their target sets.
    /// </summary>
    public static bool AreHyperEdgesInAdjacent(DirectedHyperEdge hyperEdge1, DirectedHyperEdge hyperEdge2)
    {
        Assert.NonNullReference(hyperEdge1, nameof(hyperEdge1));
        Assert.NonNullReference(hyperEdge2, nameof(hyperEdge2));

        return hyperEdge1.Codomain.Keys.Intersect(hyperEdge2.Codomain.Keys).Any();
    }

    /// <summary>
    /// Out-adjacent edges: Two directed hyperedges share at least one vertex in their source sets.
    /// </summary>
    public static bool AreHyperEdgesOutAdjacent(DirectedHyperEdge hyperEdge1, DirectedHyperEdge hyperEdge2)
    {
        Assert.NonNullReference(hyperEdge1, nameof(hyperEdge1));
        Assert.NonNullReference(hyperEdge2, nameof(hyperEdge2));

        return hyperEdge1.Domain.Keys.Intersect(hyperEdge2.Domain.Keys).Any();
    }

    /// <summary>
    /// Mixed-adjacent edges: The target set of one hyperedge shares at least one vertex with the source set of another hyperedge, forming a potential flow between them.
    /// </summary>
    public static bool AreHyperEdgesAdjacent(DirectedHyperEdge hyperEdge1, DirectedHyperEdge hyperEdge2)
    {
        Assert.NonNullReference(hyperEdge1, nameof(hyperEdge1));
        Assert.NonNullReference(hyperEdge2, nameof(hyperEdge2));

        return hyperEdge1.Codomain.Keys.Intersect(hyperEdge2.Domain.Keys).Any();
    }

    /// <summary>
    /// A singleton edge in a directed hypergraph involves exactly one vertex in either the source set, target set, or both.
    /// </summary>
    public static bool IsHyperEdgeSingleton(DirectedHyperEdge hyperEdge, SingletonEdgeType singletonEdgeType = SingletonEdgeType.SelfLoop)
    {
        Assert.NonNullReference(hyperEdge, nameof(hyperEdge));

        return singletonEdgeType switch
        {
            SingletonEdgeType.SelfLoop => hyperEdge.Domain.Count == 1 && hyperEdge.Codomain.Count == 1,
            SingletonEdgeType.SourceOnly => hyperEdge.Domain.Count == 1,
            SingletonEdgeType.TargetOnly => hyperEdge.Domain.Count > 0 && hyperEdge.Codomain.Count == 1,
            _ => false
        };
    }

    /// <summary>
    /// In-degree k-regular: Every vertex is in the target set of exactly k hyperedges.
    /// </summary>
    public static bool IsInRegular(DirectedHyperGraph graph, size k = 2)
    {
        Assert.NonNullReference(graph, nameof(graph));

        foreach(DirectedVertex vertex in graph.Vertices.Values)
        {
            if(GetVertexInDegree(graph, vertex) != k)
            {
                return false;
            }
        }

        return true;
    }

    /// <summary>
    /// Out-degree k-regular: Every vertex is in the source set of exactly k hyperedges.
    /// </summary>
    public static bool IsOutRegular(DirectedHyperGraph graph, size k = 2)
    {
        Assert.NonNullReference(graph, nameof(graph));

        foreach(DirectedVertex vertex in graph.Vertices.Values)
        {
            if(GetVertexOutDegree(graph, vertex) != k)
            {
                return false;
            }
        }

        return true;
    }

    /// <summary>
    /// A k-regular directed hypergraph requires that each vertex has exactly k hyperedges entering and exactly k hyperedges leaving.
    /// </summary>
    public static bool IsRegular(DirectedHyperGraph graph, size k = 2)
    {
        Assert.NonNullReference(graph, nameof(graph));

        foreach(DirectedVertex vertex in graph.Vertices.Values)
        {
            if(GetVertexInDegree(graph, vertex) != k || GetVertexOutDegree(graph, vertex) != k)
            {
                return false;
            }
        }

        return true;
    }

    /// <summary>
    /// Checks if the hypergraph is a k-uniform hypergraph, i.e. all hyperedges have the same k-size degree.
    /// </summary>
    public static bool IsUniform(DirectedHyperGraph graph, UniformType uniformType = UniformType.Full, size k = 2)
    {
        Assert.NonNullReference(graph, nameof(graph));

        if(uniformType == UniformType.SourceSet)
        {
            foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
            {
                if(hyperEdge.Domain.Count != k)
                {
                    return false;
                }
            }
        }
        else if(uniformType == UniformType.TargetSet)
        {
            foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
            {
                if(hyperEdge.Codomain.Count != k)
                {
                    return false;
                }
            }
        }
        else if(uniformType == UniformType.Full)
        {
            foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
            {
                if(hyperEdge.Domain.Count != k || hyperEdge.Codomain.Count != k)
                {
                    return false;
                }
            }
        }

        return true;
    }
}
