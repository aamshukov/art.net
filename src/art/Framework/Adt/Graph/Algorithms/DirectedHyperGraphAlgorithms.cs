//..............................
// UI Lab Inc. Arthur Amshukov .
//..............................
using System.Text;
using UILab.Art.Framework.Core.Diagnostics;

namespace UILab.Art.Framework.Adt.Graph;

/// <summary>
/// Some comments are generated by ChatGPT.
/// </summary>
public static class DirectedHyperGraphAlgorithms
{
    /// <summary>
    /// Gets the number of incoming edges incident to the u.
    /// If 𝑣 is in the target set of hyperedge 𝑒, we can say that 𝑒 is an incoming hyperEdge to 𝑣.
    /// </summary>
    public static count GetVertexInDegree(DirectedVertex u)
    {
        Assert.NonNullReference(u);
        return u.InHyperEdges.Count;
    }

    /// <summary>
    /// Gets the number of outcoming edges incident to the u.
    /// If 𝑣 is in the source set of hyperedge 𝑒, we can say that 𝑒 is an outgoing hyperEdge from 𝑣.
    /// </summary>
    public static count GetVertexOutDegree(DirectedVertex u)
    {
        Assert.NonNullReference(u);
        return u.OutHyperEdges.Count;
    }

    /// <summary>
    /// Gets the number of edges incident to the u.
    /// Vertex degree in a directed hypergraph can be split into in-degree and out-degree,
    /// depending on whether the u is part of the target or source set of the hyperedges.
    /// </summary>
    public static count GetVertexDegree(DirectedVertex u)
    {
        Assert.NonNullReference(u);
        return GetVertexInDegree(u) + GetVertexOutDegree(u);
    }

    /// <summary>
    /// Checks if two vertices are adjacent.
    /// There is a hyperedge 𝑒 such that 𝑢 is in the source (domain) set of 𝑒 and 𝑣 is in the target (codomain) set of 𝑒.
    /// </summary>
    public static bool AreVerticesAdjacent(DirectedVertex u, DirectedVertex v)
    {
        Assert.NonNullReference(v);
        Assert.NonNullReference(u);

        foreach(DirectedHyperEdge hyperEdge in u.OutHyperEdges.Values)
        {
            if(hyperEdge.Codomain.ContainsKey(u.Id))
            {
                return true;
            }
        }

        return false;
    }

    public static IEnumerable<DirectedVertex> GetAdjacentVertices(DirectedVertex u)
    {
        Assert.NonNullReference(u);

        foreach(DirectedHyperEdge hyperEdge in u.OutHyperEdges.Values)
        {
            foreach(DirectedVertex v in hyperEdge.Codomain.Values)
            {
                //if(ReferenceEquals(u, v))
                //    continue;

                yield return v;
            }
        }
    }

    /// <summary>
    /// A u is incident to a hyperedge if it belongs to the source or target set of that hyperedge.
    /// </summary>
    public static IEnumerable<DirectedHyperEdge> GetVertexIncidentHyperEdges(DirectedVertex u)
    {
        Assert.NonNullReference(u);

        foreach(DirectedHyperEdge hyperEdge in u.InHyperEdges.Values)
        {
            yield return hyperEdge;
        }

        foreach(DirectedHyperEdge hyperEdge in u.OutHyperEdges.Values)
        {
            yield return hyperEdge;
        }
    }

    public static bool IsVertexIsolated(DirectedVertex u)
    {
        Assert.NonNullReference(u);
        return GetVertexDegree(u) == 0;
    }

    public static bool IsVertexPendant(DirectedVertex u)
    {
        Assert.NonNullReference(u);
        return GetVertexDegree(u) == 1;
    }

    /// <summary>
    /// Out-Neighbors (or Forward Neighbors): Vertices that are in the target sets of hyperedges where the u is part of the source set.
    /// In other words, the out-neighbors of 𝑣 are the vertices that 𝑣 "points to" through the hyperedges in which 𝑣 is a source.
    /// </summary>
    public static IEnumerable<DirectedVertex> GetVertexInNeighbors(DirectedHyperGraph graph, DirectedVertex u)
    {
        Assert.NonNullReference(graph);
        Assert.NonNullReference(u);

        foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
        {
            if(hyperEdge.Codomain.ContainsKey(u.Id))
            {
                foreach(DirectedVertex neighbor in hyperEdge.Domain.Values)
                {
                    yield return neighbor;
                }
            }
        }
    }

    /// <summary>
    ///  In-Neighbors (or Backward Neighbors): Vertices that are in the source sets of hyperedges where the u is part of the target set.
    ///  The in-neighbors of 𝑣 are the vertices that "point to" 𝑣 through hyperedges in which 𝑣 is a target.
    /// </summary>
    public static IEnumerable<DirectedVertex> GetVertexOutNeighbors(DirectedHyperGraph graph, DirectedVertex u)
    {
        Assert.NonNullReference(graph);
        Assert.NonNullReference(u);

        foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
        {
            if(hyperEdge.Domain.ContainsKey(u.Id))
            {
                foreach(DirectedVertex neighbor in hyperEdge.Codomain.Values)
                {
                    yield return neighbor;
                }
            }
        }
    }

    /// <summary>
    /// Total neighbors: The union of in-neighbors and out-neighbors, representing all vertices connected to the given u by directed hyperedges.
    /// </summary>
    public static IEnumerable<DirectedVertex> GetVertexNeighbors(DirectedHyperGraph graph, DirectedVertex u)
    {
        Assert.NonNullReference(graph);
        Assert.NonNullReference(u);

        return GetVertexOutNeighbors(graph, u).Union(GetVertexInNeighbors(graph, u));
    }

    /// <summary>
    /// Predecessors of a u 𝑣 in a directed hypergraph are the vertices in the source sets of hyperedges where 𝑣 is part of the target set.
    /// They represent the vertices that "point to" 𝑣.
    /// </summary>
    public static IEnumerable<DirectedVertex> CollectPredecessors(DirectedHyperGraph graph, DirectedVertex u)
    {
        Assert.NonNullReference(graph);
        Assert.NonNullReference(u);

        return GetVertexInNeighbors(graph, u);
    }

    /// <summary>
    /// Successors of a u 𝑣 in a directed hypergraph are the vertices in the target sets of hyperedges where 𝑣 is part of the source set.
    /// They represent the vertices that 𝑣 "points to."
    /// </summary>
    public static IEnumerable<DirectedVertex> CollectSuccessors(DirectedHyperGraph graph, DirectedVertex u)
    {
        Assert.NonNullReference(graph);
        Assert.NonNullReference(u);

        return GetVertexOutNeighbors(graph, u);
    }

    /// <summary>
    /// Edge degree in a directed hypergraph is the total number of vertices in both the source and target sets of the hyperedge.
    /// </summary>
    public static count GetHyperEdgeDegree(DirectedHyperEdge hyperEdge)
    {
        Assert.NonNullReference(hyperEdge);
        return hyperEdge.Domain.Count + hyperEdge.Codomain.Count;
    }

    /// <summary>
    /// In-adjacent edges: Two directed hyperedges share at least one u in their target sets.
    /// </summary>
    public static bool AreHyperEdgesInAdjacent(DirectedHyperEdge hyperEdge1, DirectedHyperEdge hyperEdge2)
    {
        Assert.NonNullReference(hyperEdge1);
        Assert.NonNullReference(hyperEdge2);

        return hyperEdge1.Codomain.Keys.Intersect(hyperEdge2.Codomain.Keys).Any();
    }

    /// <summary>
    /// Out-adjacent edges: Two directed hyperedges share at least one u in their source sets.
    /// </summary>
    public static bool AreHyperEdgesOutAdjacent(DirectedHyperEdge hyperEdge1, DirectedHyperEdge hyperEdge2)
    {
        Assert.NonNullReference(hyperEdge1);
        Assert.NonNullReference(hyperEdge2);

        return hyperEdge1.Domain.Keys.Intersect(hyperEdge2.Domain.Keys).Any();
    }

    /// <summary>
    /// Mixed-adjacent edges: The target set of one hyperedge shares at least one u with the source set of another hyperedge, forming a potential flow between them.
    /// </summary>
    public static bool AreHyperEdgesAdjacent(DirectedHyperEdge hyperEdge1, DirectedHyperEdge hyperEdge2)
    {
        Assert.NonNullReference(hyperEdge1);
        Assert.NonNullReference(hyperEdge2);

        return hyperEdge1.Codomain.Keys.Intersect(hyperEdge2.Domain.Keys).Any();
    }

    /// <summary>
    /// A singleton hyperEdge in a directed hypergraph involves exactly one u in either the source set, target set, or both.
    /// </summary>
    public static bool IsHyperEdgeSingleton(DirectedHyperEdge hyperEdge, SingletonEdgeType singletonEdgeType = SingletonEdgeType.SelfLoop)
    {
        Assert.NonNullReference(hyperEdge   );

        return singletonEdgeType switch
        {
            SingletonEdgeType.SelfLoop => hyperEdge.Domain.Count == 1 && hyperEdge.Codomain.Count == 1,
            SingletonEdgeType.SourceOnly => hyperEdge.Domain.Count == 1,
            SingletonEdgeType.TargetOnly => hyperEdge.Domain.Count > 0 && hyperEdge.Codomain.Count == 1,
            _ => false
        };
    }

    /// <summary>
    /// In-degree k-regular: Every u is in the target set of exactly k hyperedges.
    /// </summary>
    public static bool IsInRegular(DirectedHyperGraph graph, size k = 2)
    {
        Assert.NonNullReference(graph);

        foreach(DirectedVertex vertex in graph.Vertices.Values)
        {
            if(GetVertexInDegree(vertex) != k)
            {
                return false;
            }
        }

        return true;
    }

    /// <summary>
    /// Out-degree k-regular: Every u is in the source set of exactly k hyperedges.
    /// </summary>
    public static bool IsOutRegular(DirectedHyperGraph graph, size k = 2)
    {
        Assert.NonNullReference(graph);

        foreach(DirectedVertex vertex in graph.Vertices.Values)
        {
            if(GetVertexOutDegree(vertex) != k)
            {
                return false;
            }
        }

        return true;
    }

    /// <summary>
    /// A k-regular directed hypergraph requires that each u has exactly k hyperedges entering and exactly k hyperedges leaving.
    /// </summary>
    public static bool IsRegular(DirectedHyperGraph graph, size k = 2)
    {
        Assert.NonNullReference(graph);

        foreach(DirectedVertex vertex in graph.Vertices.Values)
        {
            if(GetVertexInDegree(vertex) != k || GetVertexOutDegree(vertex) != k)
            {
                return false;
            }
        }

        return true;
    }

    /// <summary>
    /// Checks if the hypergraph is a k-uniform hypergraph, i.e. all hyperedges have the same k-size degree.
    /// </summary>
    public static bool IsUniform(DirectedHyperGraph graph, UniformType uniformType = UniformType.Full, size k = 2)
    {
        Assert.NonNullReference(graph);

        if(uniformType == UniformType.SourceSet)
        {
            foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
            {
                if(hyperEdge.Domain.Count != k)
                {
                    return false;
                }
            }
        }
        else if(uniformType == UniformType.TargetSet)
        {
            foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
            {
                if(hyperEdge.Codomain.Count != k)
                {
                    return false;
                }
            }
        }
        else if(uniformType == UniformType.Full)
        {
            foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
            {
                if(hyperEdge.Domain.Count != k || hyperEdge.Codomain.Count != k)
                {
                    return false;
                }
            }
        }

        return true;
    }

    public static bool IsLeaf(DirectedVertex u)
    {
        count degree = GetVertexOutDegree(u);
        return degree == 1 || degree == 0;
    }

    public static DirectedVertex ContractHyperEdge(DirectedHyperGraph graph, DirectedHyperEdge contractedHyperEdge)
    {
        Assert.NonNullReference(graph);
        Assert.NonNullReference(contractedHyperEdge);

        var domain = contractedHyperEdge.Domain.Values;
        var codomain = contractedHyperEdge.Codomain.Values;

        var contractedHyperEdgeVertices = domain.Union(codomain);

        // Merge the source and target vertices.
        // Create a new vertex 𝑣𝑒 to represent all vertices in 𝑆(𝑒)∪𝑇(𝑒) (i.e., both the source and target vertices in the hyperedge).
        DirectedVertex contractedVertex = MergeVertices(graph, domain, codomain);

        graph.AddVertex(contractedVertex);
        
        // Replace all occurrences of the vertices in 𝑆(𝑒)∪𝑇(𝑒), (the vertices in the contracted hyperedge) with 𝑣𝑒.
        foreach(DirectedHyperEdge hyperEdge in graph.HyperEdges.Values)
        {
            if(ReferenceEquals(hyperEdge, contractedHyperEdge))
                continue;

            ReplaceVertices(contractedHyperEdgeVertices, hyperEdge, domain: true);
            ReplaceVertices(contractedHyperEdgeVertices, hyperEdge, domain: false);

            void ReplaceVertices(IEnumerable<DirectedVertex> contractedHyperEdgeVertices,
                                 DirectedHyperEdge hyperEdge,
                                 bool domain)
            {
                var edgeVertices = domain ? hyperEdge.Domain.Values : hyperEdge.Codomain.Values;

                List<DirectedVertex> verticesToRemove = new();

                foreach(DirectedVertex vertex in edgeVertices)
                {
                    if(contractedHyperEdgeVertices.Contains(vertex))
                    {
                        verticesToRemove.Add(vertex);
                    }
                }

                if(verticesToRemove.Count > 0)
                {
                    // If any hyperedges involve both a source and target vertex from 𝑆(𝑒)∪𝑇(𝑒), they collapse into a self-loop at 𝑣𝑒.
                    // This happens automatically as we remove all vertices in case they are the same as in the contracting hyperedge.
                    foreach(DirectedVertex vertex in verticesToRemove)
                    {
                        hyperEdge.RemoveVertex(vertex.Id, domain);
                    }

                    hyperEdge.AddVertex(contractedVertex, domain);
                }
            }
        }

        // Remove the original hyperedge 𝑒 after contraction.
        graph.RemoveHyperEdge(contractedHyperEdge.Id, RemoveActionType.Weak);

        graph.Cleanup();

        return contractedVertex;
    }

    private static DirectedVertex MergeVertices(DirectedHyperGraph graph,
                                                IEnumerable<DirectedVertex> domain,
                                                IEnumerable<DirectedVertex> codomain)
    {
        StringBuilder sb = new("V");

        foreach(DirectedVertex vertex in domain)
        {
            sb.Append($":{vertex.Label}(d)");
        }

        foreach(DirectedVertex vertex in codomain)
        {
            sb.Append($":{vertex.Label}(c)");
        }

        DirectedVertex contractedVertex = graph.CreateVertex(label: sb.ToString());
        return contractedVertex;
    }

    public static IEnumerable<DirectedVertex> GetSelfLoopVertices(DirectedHyperEdge hyperEdge)
    {
        Assert.NonNullReference(hyperEdge);

        if(hyperEdge.Domain.Count == 1 && hyperEdge.Codomain.Count == 1)
        {
            if(hyperEdge.Domain.First().Value.Id == hyperEdge.Codomain.First().Value.Id)
            {
                yield return hyperEdge.Domain.First().Value;
            }
        }
        else
        {
            var grouppedVertices = hyperEdge.Domain.Values.IntersectBy(hyperEdge.Codomain.Values.Select(u => u.Id), v => v.Id);

            foreach(var vertex in grouppedVertices)
            {
                yield return vertex;
            }
        }
    }

    public static IEnumerable<DirectedVertex> Dfs(DirectedHyperGraph graph,
                                                  DirectedVertex u,
                                                  bool preorder = true,
                                                  IObserver<DirectedVertex>? observer = default)
    {
        Assert.NonNullReference(graph);
        Assert.NonNullReference(u);

        Stack<DirectedVertex> stack = new();

        stack.Push(u);

        while(stack.Count > 0)
        {
            DirectedVertex v = stack.Pop();

            if(v.Flags.Has(Flags.Visited))
                continue;

            v.Flags = HyperGraphAlgorithms.ModifyFlags(v.Flags, add: Flags.Visited);

            if(preorder)
            {
                observer?.OnNext(v);
                yield return v;
            }

            foreach(DirectedVertex v_adjacence in DirectedHyperGraphAlgorithms.GetAdjacentVertices(v))
            {
                if(v_adjacence.Flags.HasNot(Flags.Visited))
                {
                    stack.Push(v_adjacence);
                }
            }

            if(!preorder) // postorder
            {
                observer?.OnNext(v);
                yield return v;
            }
        }

        observer?.OnCompleted();

        graph.ResetFlags(remove: Flags.Visited);
    }

    public static IEnumerable<DirectedVertex> Bfs(DirectedHyperGraph graph,
                                                  DirectedVertex u,
                                                  bool preorder = true,
                                                  IObserver<DirectedVertex>? observer = default)
    {
        Assert.NonNullReference(graph);
        Assert.NonNullReference(u);

        Queue<DirectedVertex> queue = new();

        queue.Enqueue(u);

        while(queue.Count > 0)
        {
            DirectedVertex v = queue.Dequeue();

            if(v.Flags.Has(Flags.Visited))
                continue;

            v.Flags = HyperGraphAlgorithms.ModifyFlags(v.Flags, add: Flags.Visited);

            if(preorder)
            {
                observer?.OnNext(v);
                yield return v;
            }

            foreach(DirectedVertex v_adjacence in DirectedHyperGraphAlgorithms.GetAdjacentVertices(v))
            {
                if(v_adjacence.Flags.HasNot(Flags.Visited))
                {
                    queue.Enqueue(v_adjacence);
                }
            }

            if(!preorder) // postorder
            {
                observer?.OnNext(v);
                yield return v;
            }
        }

        observer?.OnCompleted();

        graph.ResetFlags(remove: Flags.Visited);
    }
}
