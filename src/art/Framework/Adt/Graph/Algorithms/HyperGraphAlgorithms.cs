//..............................
// UI Lab Inc. Arthur Amshukov .
//..............................
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using UILab.Art.Framework.Core.Diagnostics;

namespace UILab.Art.Framework.Adt.Graph;

/// <summary>
/// Some comments are generated by ChatGPT.
/// </summary>
public static class HyperGraphAlgorithms
{
    public static Flags ModifyFlags(Flags flags, Flags add = Flags.Clear, Flags remove = Flags.Clear)
    {
        return flags & ~remove | add;
    }

    public static bool Has(this Flags self, Flags other)
    {
        return (self & other) == other;
    }

    public static bool HasNot(this Flags self, Flags other)
    {
        return (self & other) != other;
    }

    public static void ReadNxGraph(string nxFilePath,
                                   string nxFileName,
                                   out string label,
                                   out bool digraph,
                                   out List<id> vertices,
                                   out List<List<id>> endPoints)
    {
        Assert.NonEmptyString(nxFilePath);

        var jContent = File.ReadAllText(Path.Combine(nxFilePath, nxFileName));
        var jToken = (JToken)JsonConvert.DeserializeObject(jContent,
                                                           new JsonSerializerSettings
                                                           {
                                                               MissingMemberHandling = MissingMemberHandling.Ignore,
                                                               NullValueHandling = NullValueHandling.Include,
                                                               DefaultValueHandling = DefaultValueHandling.IgnoreAndPopulate,
                                                               Formatting = Formatting.Indented,
                                                               DateFormatHandling = DateFormatHandling.IsoDateFormat,
                                                               DateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind,
                                                               DateParseHandling = DateParseHandling.DateTimeOffset,
                                                               StringEscapeHandling = StringEscapeHandling.EscapeHtml
                                                           })!;

        var jNodes = jToken.SelectToken("nodes")!;

        label = Path.GetFileNameWithoutExtension(nxFileName);
        digraph = jToken.SelectToken("directed")?.ToString() == "True";
        vertices = new();
        endPoints = new();

        foreach(var jNode in jNodes)
        {
            var vertexId = jNode.Value<int>("id") + 1;
            vertices.Add(vertexId);
        }

        var jAdjacencies = jToken.SelectToken("adjacency")!;

        foreach(var jAdjEdges in jAdjacencies)
        {
            List<id> adjVertexIds = new();

            foreach(var jEdge in jAdjEdges)
            {
                var vertexId = jEdge.Value<int>("id") + 1;
                adjVertexIds.Add(vertexId);
            }

            endPoints.Add(adjVertexIds);
        }
    }

    //public static bool IsRoot<TVertex>(TVertex vertex)
    //    where TVertex : EntityType<id>
    //{
    //    return false;
    //}


    //public static bool IsBHyperEdge<TVertex, TEdge>(HyperEdge<TVertex> hyperEdge)
    //    where TVertex : EntityType<id>
    //    where TEdge : EntityType<id>
    //{
    //    return hyperEdge.Domain.Count == 1;
    //}

    //public static bool IsFHyperEdge<TVertex, TEdge>(HyperEdge<TVertex> hyperEdge)
    //    where TVertex : EntityType<id>
    //    where TEdge : EntityType<id>
    //{
    //    return hyperEdge.Codomain.Count == 1;
    //}

    //public static IEnumerable<HyperEdge<TVertex>> GetVertexForwardStar<TVertex, TEdge>(HyperGraph<TVertex, TEdge> hyperGraph,
    //                                                                                          TVertex vertex)
    //    where TVertex : EntityType<id>
    //    where TEdge : EntityType<id>
    //{
    //    //yield return (HyperEdge<TVertex, TEdge>)Enumerable.Empty<HyperEdge<TVertex, TEdge>>();
    //    throw new NotImplementedException();
    //}

    //public static IEnumerable<HyperEdge<TVertex>> GetVertexBackwardStar<TVertex, TEdge>(HyperGraph<TVertex, TEdge> hyperGraph,
    //                                                                                           TVertex vertex)
    //    where TVertex : EntityType<id>
    //    where TEdge : EntityType<id>
    //{
    //    //yield return (HyperEdge<TVertex, TEdge>)Enumerable.Empty<HyperEdge<TVertex, TEdge>>();
    //    throw new NotImplementedException();
    //}



    ///// <summary>
    ///// Calculates incidence matrix: V𝑛, E𝑚 then incidence matrix of size [𝑛, 𝑚].
    ///// Values might be:
    /////     undirected - 0, 1, 2
    /////     directed   - 0, 1
    ///// </summary>
    //public byte[,] CalculateIncidenceMatrix()
    //{
    //    size n = 0;
    //    size m = 0;

    //    byte[,] matrix = new byte[n, m];

    //    return matrix;
    //}

    ///// <summary>
    ///// Calculates adjacency matrix: V𝑛, V𝑛 then adjacency matrix of size [𝑛, n].
    ///// Values might be: 0, 1
    ///// </summary>
    //public byte[,] CalculateAdjacencyMatrix()
    //{
    //    size n = 0;

    //    byte[,] matrix = new byte[n, n];

    //    return matrix;
    //}






    ///// <summary>
    ///// Finds an edge that connects the vertex U to the vertex V.
    ///// </summary>
    ///// <param name="u"></param>
    ///// <param name="v"></param>
    //public TEdge? FindEdge(TVertex u, TVertex v)
    //{
    //    Assert.NonNullReference(u, nameof(u));
    //    Assert.NonNullReference(v, nameof(v));
    //    return default;
    //}

    ///// <summary>
    ///// Finds all edgeIds that connects the vertex U to the vertex V.
    ///// </summary>
    ///// <param name="u"></param>
    ///// <param name="v"></param>
    //public IEnumerable<TEdge> FindEdges(TVertex u, TVertex v)
    //{
    //    Assert.NonNullReference(u, nameof(u));
    //    Assert.NonNullReference(v, nameof(v));
    //    yield return (TEdge)Enumerable.Empty<TEdge>();
    //}

}
